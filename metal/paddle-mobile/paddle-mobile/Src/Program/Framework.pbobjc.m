// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: Framework.proto

// This CPP symbol can be defined to use imports that match up to the framework
// imports needed when using CocoaPods.
#if !defined(GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS)
 #define GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS 0
#endif

//#if GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS
// #import <Protobuf/GPBProtocolBuffers_RuntimeSupport.h>
//#else
// #import "GPBProtocolBuffers_RuntimeSupport.h"
//#endif

#if GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS
#import <Protobuf/GPBProtocolBuffers_RuntimeSupport.h>
#else
#import <ProtocolBuffers/GPBProtocolBuffers_RuntimeSupport.h>
#endif

 #import "Framework.pbobjc.h"
// @@protoc_insertion_point(imports)

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"

#pragma mark - FrameworkRoot

@implementation FrameworkRoot

@end

#pragma mark - FrameworkRoot_FileDescriptor

static GPBFileDescriptor *FrameworkRoot_FileDescriptor(void) {
  // This is called by +initialize so there is no need to worry
  // about thread safety of the singleton.
  static GPBFileDescriptor *descriptor = NULL;
  if (!descriptor) {
    GPBDebugCheckRuntimeVersion();
    descriptor = [[GPBFileDescriptor alloc] initWithPackage:@"paddle_mobile.framework.proto"
                                                     syntax:GPBFileSyntaxProto2];
  }
  return descriptor;
}

#pragma mark - Enum AttrType

GPBEnumDescriptor *AttrType_EnumDescriptor(void) {
  static GPBEnumDescriptor *descriptor = NULL;
  if (!descriptor) {
    static const char *valueNames =
        "Int\000Float\000String\000Ints\000Floats\000Strings\000Boo"
        "lean\000Booleans\000Block\000Long\000Blocks\000";
    static const int32_t values[] = {
        AttrType_Int,
        AttrType_Float,
        AttrType_String,
        AttrType_Ints,
        AttrType_Floats,
        AttrType_Strings,
        AttrType_Boolean,
        AttrType_Booleans,
        AttrType_Block,
        AttrType_Long,
        AttrType_Blocks,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(AttrType)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:AttrType_IsValidValue];
    if (!OSAtomicCompareAndSwapPtrBarrier(nil, worker, (void * volatile *)&descriptor)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL AttrType_IsValidValue(int32_t value__) {
  switch (value__) {
    case AttrType_Int:
    case AttrType_Float:
    case AttrType_String:
    case AttrType_Ints:
    case AttrType_Floats:
    case AttrType_Strings:
    case AttrType_Boolean:
    case AttrType_Booleans:
    case AttrType_Block:
    case AttrType_Long:
    case AttrType_Blocks:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Version

@implementation Version

@dynamic hasVersion, version;

typedef struct Version__storage_ {
  uint32_t _has_storage_[1];
  int64_t version;
} Version__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "version",
        .dataTypeSpecific.className = NULL,
        .number = Version_FieldNumber_Version,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Version__storage_, version),
        .flags = GPBFieldOptional | GPBFieldHasDefaultValue,
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Version class]
                                     rootClass:[FrameworkRoot class]
                                          file:FrameworkRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Version__storage_)
                                         flags:0];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - OpDesc

@implementation OpDesc

@dynamic hasType, type;
@dynamic inputsArray, inputsArray_Count;
@dynamic outputsArray, outputsArray_Count;
@dynamic attrsArray, attrsArray_Count;
@dynamic hasIsTarget, isTarget;

typedef struct OpDesc__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *inputsArray;
  NSMutableArray *outputsArray;
  NSString *type;
  NSMutableArray *attrsArray;
} OpDesc__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "inputsArray",
        .dataTypeSpecific.className = GPBStringifySymbol(OpDesc_Var),
        .number = OpDesc_FieldNumber_InputsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(OpDesc__storage_, inputsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "outputsArray",
        .dataTypeSpecific.className = GPBStringifySymbol(OpDesc_Var),
        .number = OpDesc_FieldNumber_OutputsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(OpDesc__storage_, outputsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "type",
        .dataTypeSpecific.className = NULL,
        .number = OpDesc_FieldNumber_Type,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(OpDesc__storage_, type),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "attrsArray",
        .dataTypeSpecific.className = GPBStringifySymbol(OpDesc_Attr),
        .number = OpDesc_FieldNumber_AttrsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(OpDesc__storage_, attrsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "isTarget",
        .dataTypeSpecific.className = NULL,
        .number = OpDesc_FieldNumber_IsTarget,
        .hasIndex = 1,
        .offset = 2,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional | GPBFieldHasDefaultValue,
        .dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[OpDesc class]
                                     rootClass:[FrameworkRoot class]
                                          file:FrameworkRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(OpDesc__storage_)
                                         flags:0];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - OpDesc_Attr

@implementation OpDesc_Attr

@dynamic hasName, name;
@dynamic hasType, type;
@dynamic hasI, i;
@dynamic hasF, f;
@dynamic hasS, s;
@dynamic intsArray, intsArray_Count;
@dynamic floatsArray, floatsArray_Count;
@dynamic stringsArray, stringsArray_Count;
@dynamic hasB, b;
@dynamic boolsArray, boolsArray_Count;
@dynamic hasBlockIdx, blockIdx;
@dynamic hasL, l;
@dynamic blocksIdxArray, blocksIdxArray_Count;

typedef struct OpDesc_Attr__storage_ {
  uint32_t _has_storage_[1];
  AttrType type;
  int32_t i;
  float f;
  int32_t blockIdx;
  NSString *name;
  NSString *s;
  GPBInt32Array *intsArray;
  GPBFloatArray *floatsArray;
  NSMutableArray *stringsArray;
  GPBBoolArray *boolsArray;
  GPBInt32Array *blocksIdxArray;
  int64_t l;
} OpDesc_Attr__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "name",
        .dataTypeSpecific.className = NULL,
        .number = OpDesc_Attr_FieldNumber_Name,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(OpDesc_Attr__storage_, name),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "type",
        .dataTypeSpecific.enumDescFunc = AttrType_EnumDescriptor,
        .number = OpDesc_Attr_FieldNumber_Type,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(OpDesc_Attr__storage_, type),
        .flags = GPBFieldRequired | GPBFieldHasEnumDescriptor,
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "i",
        .dataTypeSpecific.className = NULL,
        .number = OpDesc_Attr_FieldNumber_I,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(OpDesc_Attr__storage_, i),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "f",
        .dataTypeSpecific.className = NULL,
        .number = OpDesc_Attr_FieldNumber_F,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(OpDesc_Attr__storage_, f),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeFloat,
      },
      {
        .name = "s",
        .dataTypeSpecific.className = NULL,
        .number = OpDesc_Attr_FieldNumber_S,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(OpDesc_Attr__storage_, s),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "intsArray",
        .dataTypeSpecific.className = NULL,
        .number = OpDesc_Attr_FieldNumber_IntsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(OpDesc_Attr__storage_, intsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "floatsArray",
        .dataTypeSpecific.className = NULL,
        .number = OpDesc_Attr_FieldNumber_FloatsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(OpDesc_Attr__storage_, floatsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeFloat,
      },
      {
        .name = "stringsArray",
        .dataTypeSpecific.className = NULL,
        .number = OpDesc_Attr_FieldNumber_StringsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(OpDesc_Attr__storage_, stringsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "b",
        .dataTypeSpecific.className = NULL,
        .number = OpDesc_Attr_FieldNumber_B,
        .hasIndex = 5,
        .offset = 6,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "boolsArray",
        .dataTypeSpecific.className = NULL,
        .number = OpDesc_Attr_FieldNumber_BoolsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(OpDesc_Attr__storage_, boolsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "blockIdx",
        .dataTypeSpecific.className = NULL,
        .number = OpDesc_Attr_FieldNumber_BlockIdx,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(OpDesc_Attr__storage_, blockIdx),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "l",
        .dataTypeSpecific.className = NULL,
        .number = OpDesc_Attr_FieldNumber_L,
        .hasIndex = 8,
        .offset = (uint32_t)offsetof(OpDesc_Attr__storage_, l),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "blocksIdxArray",
        .dataTypeSpecific.className = NULL,
        .number = OpDesc_Attr_FieldNumber_BlocksIdxArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(OpDesc_Attr__storage_, blocksIdxArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[OpDesc_Attr class]
                                     rootClass:[FrameworkRoot class]
                                          file:FrameworkRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(OpDesc_Attr__storage_)
                                         flags:0];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - OpDesc_Var

@implementation OpDesc_Var

@dynamic hasParameter, parameter;
@dynamic argumentsArray, argumentsArray_Count;

typedef struct OpDesc_Var__storage_ {
  uint32_t _has_storage_[1];
  NSString *parameter;
  NSMutableArray *argumentsArray;
} OpDesc_Var__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "parameter",
        .dataTypeSpecific.className = NULL,
        .number = OpDesc_Var_FieldNumber_Parameter,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(OpDesc_Var__storage_, parameter),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "argumentsArray",
        .dataTypeSpecific.className = NULL,
        .number = OpDesc_Var_FieldNumber_ArgumentsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(OpDesc_Var__storage_, argumentsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[OpDesc_Var class]
                                     rootClass:[FrameworkRoot class]
                                          file:FrameworkRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(OpDesc_Var__storage_)
                                         flags:0];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - OpProto

@implementation OpProto

@dynamic hasType, type;
@dynamic inputsArray, inputsArray_Count;
@dynamic outputsArray, outputsArray_Count;
@dynamic attrsArray, attrsArray_Count;
@dynamic hasComment, comment;

typedef struct OpProto__storage_ {
  uint32_t _has_storage_[1];
  NSString *type;
  NSMutableArray *inputsArray;
  NSMutableArray *outputsArray;
  NSMutableArray *attrsArray;
  NSString *comment;
} OpProto__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "type",
        .dataTypeSpecific.className = NULL,
        .number = OpProto_FieldNumber_Type,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(OpProto__storage_, type),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "inputsArray",
        .dataTypeSpecific.className = GPBStringifySymbol(OpProto_Var),
        .number = OpProto_FieldNumber_InputsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(OpProto__storage_, inputsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "outputsArray",
        .dataTypeSpecific.className = GPBStringifySymbol(OpProto_Var),
        .number = OpProto_FieldNumber_OutputsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(OpProto__storage_, outputsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "attrsArray",
        .dataTypeSpecific.className = GPBStringifySymbol(OpProto_Attr),
        .number = OpProto_FieldNumber_AttrsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(OpProto__storage_, attrsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "comment",
        .dataTypeSpecific.className = NULL,
        .number = OpProto_FieldNumber_Comment,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(OpProto__storage_, comment),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[OpProto class]
                                     rootClass:[FrameworkRoot class]
                                          file:FrameworkRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(OpProto__storage_)
                                         flags:0];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - OpProto_Var

@implementation OpProto_Var

@dynamic hasName, name;
@dynamic hasComment, comment;
@dynamic hasDuplicable, duplicable;
@dynamic hasIntermediate, intermediate;
@dynamic hasDispensable, dispensable;
@dynamic hasReuse, reuse;

typedef struct OpProto_Var__storage_ {
  uint32_t _has_storage_[1];
  NSString *name;
  NSString *comment;
  NSString *reuse;
} OpProto_Var__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "name",
        .dataTypeSpecific.className = NULL,
        .number = OpProto_Var_FieldNumber_Name,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(OpProto_Var__storage_, name),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "comment",
        .dataTypeSpecific.className = NULL,
        .number = OpProto_Var_FieldNumber_Comment,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(OpProto_Var__storage_, comment),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "duplicable",
        .dataTypeSpecific.className = NULL,
        .number = OpProto_Var_FieldNumber_Duplicable,
        .hasIndex = 2,
        .offset = 3,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional | GPBFieldHasDefaultValue,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "intermediate",
        .dataTypeSpecific.className = NULL,
        .number = OpProto_Var_FieldNumber_Intermediate,
        .hasIndex = 4,
        .offset = 5,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional | GPBFieldHasDefaultValue,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "dispensable",
        .dataTypeSpecific.className = NULL,
        .number = OpProto_Var_FieldNumber_Dispensable,
        .hasIndex = 6,
        .offset = 7,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional | GPBFieldHasDefaultValue,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "reuse",
        .dataTypeSpecific.className = NULL,
        .number = OpProto_Var_FieldNumber_Reuse,
        .hasIndex = 8,
        .offset = (uint32_t)offsetof(OpProto_Var__storage_, reuse),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[OpProto_Var class]
                                     rootClass:[FrameworkRoot class]
                                          file:FrameworkRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(OpProto_Var__storage_)
                                         flags:0];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - OpProto_Attr

@implementation OpProto_Attr

@dynamic hasName, name;
@dynamic hasType, type;
@dynamic hasComment, comment;
@dynamic hasGenerated, generated;

typedef struct OpProto_Attr__storage_ {
  uint32_t _has_storage_[1];
  AttrType type;
  NSString *name;
  NSString *comment;
} OpProto_Attr__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "name",
        .dataTypeSpecific.className = NULL,
        .number = OpProto_Attr_FieldNumber_Name,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(OpProto_Attr__storage_, name),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "type",
        .dataTypeSpecific.enumDescFunc = AttrType_EnumDescriptor,
        .number = OpProto_Attr_FieldNumber_Type,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(OpProto_Attr__storage_, type),
        .flags = GPBFieldRequired | GPBFieldHasEnumDescriptor,
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "comment",
        .dataTypeSpecific.className = NULL,
        .number = OpProto_Attr_FieldNumber_Comment,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(OpProto_Attr__storage_, comment),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "generated",
        .dataTypeSpecific.className = NULL,
        .number = OpProto_Attr_FieldNumber_Generated,
        .hasIndex = 3,
        .offset = 4,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional | GPBFieldHasDefaultValue,
        .dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[OpProto_Attr class]
                                     rootClass:[FrameworkRoot class]
                                          file:FrameworkRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(OpProto_Attr__storage_)
                                         flags:0];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - VarType

@implementation VarType

@dynamic hasType, type;
@dynamic hasSelectedRows, selectedRows;
@dynamic hasLodTensor, lodTensor;
@dynamic hasTensorArray_p, tensorArray_p;
@dynamic hasReader, reader;
@dynamic hasChannel, channel;
@dynamic hasTuple, tuple;

typedef struct VarType__storage_ {
  uint32_t _has_storage_[1];
  VarType_Type type;
  VarType_TensorDesc *selectedRows;
  VarType_LoDTensorDesc *lodTensor;
  VarType_LoDTensorArrayDesc *tensorArray_p;
  VarType_ReaderDesc *reader;
  VarType_ChannelDesc *channel;
  VarType_Tuple *tuple;
} VarType__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "type",
        .dataTypeSpecific.enumDescFunc = VarType_Type_EnumDescriptor,
        .number = VarType_FieldNumber_Type,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(VarType__storage_, type),
        .flags = GPBFieldRequired | GPBFieldHasEnumDescriptor,
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "selectedRows",
        .dataTypeSpecific.className = GPBStringifySymbol(VarType_TensorDesc),
        .number = VarType_FieldNumber_SelectedRows,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(VarType__storage_, selectedRows),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "lodTensor",
        .dataTypeSpecific.className = GPBStringifySymbol(VarType_LoDTensorDesc),
        .number = VarType_FieldNumber_LodTensor,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(VarType__storage_, lodTensor),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "tensorArray_p",
        .dataTypeSpecific.className = GPBStringifySymbol(VarType_LoDTensorArrayDesc),
        .number = VarType_FieldNumber_TensorArray_p,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(VarType__storage_, tensorArray_p),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "reader",
        .dataTypeSpecific.className = GPBStringifySymbol(VarType_ReaderDesc),
        .number = VarType_FieldNumber_Reader,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(VarType__storage_, reader),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "channel",
        .dataTypeSpecific.className = GPBStringifySymbol(VarType_ChannelDesc),
        .number = VarType_FieldNumber_Channel,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(VarType__storage_, channel),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "tuple",
        .dataTypeSpecific.className = GPBStringifySymbol(VarType_Tuple),
        .number = VarType_FieldNumber_Tuple,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(VarType__storage_, tuple),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[VarType class]
                                     rootClass:[FrameworkRoot class]
                                          file:FrameworkRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(VarType__storage_)
                                         flags:0];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Enum VarType_Type

GPBEnumDescriptor *VarType_Type_EnumDescriptor(void) {
  static GPBEnumDescriptor *descriptor = NULL;
  if (!descriptor) {
    static const char *valueNames =
        "Bool\000Int16\000Int32\000Int64\000Fp16\000Fp32\000Fp64\000Si"
        "zeT\000Uint8\000Int8\000LodTensor\000SelectedRows\000Fe"
        "edMinibatch\000FetchList\000StepScopes\000LodRank"
        "Table\000LodTensorArray\000PlaceList\000Reader\000Ch"
        "annel\000Raw\000Tuple\000";
    static const int32_t values[] = {
        VarType_Type_Bool,
        VarType_Type_Int16,
        VarType_Type_Int32,
        VarType_Type_Int64,
        VarType_Type_Fp16,
        VarType_Type_Fp32,
        VarType_Type_Fp64,
        VarType_Type_SizeT,
        VarType_Type_Uint8,
        VarType_Type_Int8,
        VarType_Type_LodTensor,
        VarType_Type_SelectedRows,
        VarType_Type_FeedMinibatch,
        VarType_Type_FetchList,
        VarType_Type_StepScopes,
        VarType_Type_LodRankTable,
        VarType_Type_LodTensorArray,
        VarType_Type_PlaceList,
        VarType_Type_Reader,
        VarType_Type_Channel,
        VarType_Type_Raw,
        VarType_Type_Tuple,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(VarType_Type)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:VarType_Type_IsValidValue];
    if (!OSAtomicCompareAndSwapPtrBarrier(nil, worker, (void * volatile *)&descriptor)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL VarType_Type_IsValidValue(int32_t value__) {
  switch (value__) {
    case VarType_Type_Bool:
    case VarType_Type_Int16:
    case VarType_Type_Int32:
    case VarType_Type_Int64:
    case VarType_Type_Fp16:
    case VarType_Type_Fp32:
    case VarType_Type_Fp64:
    case VarType_Type_SizeT:
    case VarType_Type_Uint8:
    case VarType_Type_Int8:
    case VarType_Type_LodTensor:
    case VarType_Type_SelectedRows:
    case VarType_Type_FeedMinibatch:
    case VarType_Type_FetchList:
    case VarType_Type_StepScopes:
    case VarType_Type_LodRankTable:
    case VarType_Type_LodTensorArray:
    case VarType_Type_PlaceList:
    case VarType_Type_Reader:
    case VarType_Type_Channel:
    case VarType_Type_Raw:
    case VarType_Type_Tuple:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - VarType_TensorDesc

@implementation VarType_TensorDesc

@dynamic hasDataType, dataType;
@dynamic dimsArray, dimsArray_Count;

typedef struct VarType_TensorDesc__storage_ {
  uint32_t _has_storage_[1];
  VarType_Type dataType;
  GPBInt64Array *dimsArray;
} VarType_TensorDesc__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "dataType",
        .dataTypeSpecific.enumDescFunc = VarType_Type_EnumDescriptor,
        .number = VarType_TensorDesc_FieldNumber_DataType,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(VarType_TensorDesc__storage_, dataType),
        .flags = GPBFieldRequired | GPBFieldHasEnumDescriptor,
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "dimsArray",
        .dataTypeSpecific.className = NULL,
        .number = VarType_TensorDesc_FieldNumber_DimsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(VarType_TensorDesc__storage_, dimsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[VarType_TensorDesc class]
                                     rootClass:[FrameworkRoot class]
                                          file:FrameworkRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(VarType_TensorDesc__storage_)
                                         flags:0];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - VarType_LoDTensorDesc

@implementation VarType_LoDTensorDesc

@dynamic hasTensor, tensor;
@dynamic hasLodLevel, lodLevel;

typedef struct VarType_LoDTensorDesc__storage_ {
  uint32_t _has_storage_[1];
  int32_t lodLevel;
  VarType_TensorDesc *tensor;
} VarType_LoDTensorDesc__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "tensor",
        .dataTypeSpecific.className = GPBStringifySymbol(VarType_TensorDesc),
        .number = VarType_LoDTensorDesc_FieldNumber_Tensor,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(VarType_LoDTensorDesc__storage_, tensor),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "lodLevel",
        .dataTypeSpecific.className = NULL,
        .number = VarType_LoDTensorDesc_FieldNumber_LodLevel,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(VarType_LoDTensorDesc__storage_, lodLevel),
        .flags = GPBFieldOptional | GPBFieldHasDefaultValue,
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[VarType_LoDTensorDesc class]
                                     rootClass:[FrameworkRoot class]
                                          file:FrameworkRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(VarType_LoDTensorDesc__storage_)
                                         flags:0];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - VarType_LoDTensorArrayDesc

@implementation VarType_LoDTensorArrayDesc

@dynamic hasTensor, tensor;
@dynamic hasLodLevel, lodLevel;

typedef struct VarType_LoDTensorArrayDesc__storage_ {
  uint32_t _has_storage_[1];
  int32_t lodLevel;
  VarType_TensorDesc *tensor;
} VarType_LoDTensorArrayDesc__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "tensor",
        .dataTypeSpecific.className = GPBStringifySymbol(VarType_TensorDesc),
        .number = VarType_LoDTensorArrayDesc_FieldNumber_Tensor,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(VarType_LoDTensorArrayDesc__storage_, tensor),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "lodLevel",
        .dataTypeSpecific.className = NULL,
        .number = VarType_LoDTensorArrayDesc_FieldNumber_LodLevel,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(VarType_LoDTensorArrayDesc__storage_, lodLevel),
        .flags = GPBFieldOptional | GPBFieldHasDefaultValue,
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[VarType_LoDTensorArrayDesc class]
                                     rootClass:[FrameworkRoot class]
                                          file:FrameworkRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(VarType_LoDTensorArrayDesc__storage_)
                                         flags:0];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - VarType_ReaderDesc

@implementation VarType_ReaderDesc

@dynamic lodTensorArray, lodTensorArray_Count;

typedef struct VarType_ReaderDesc__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *lodTensorArray;
} VarType_ReaderDesc__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "lodTensorArray",
        .dataTypeSpecific.className = GPBStringifySymbol(VarType_LoDTensorDesc),
        .number = VarType_ReaderDesc_FieldNumber_LodTensorArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(VarType_ReaderDesc__storage_, lodTensorArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[VarType_ReaderDesc class]
                                     rootClass:[FrameworkRoot class]
                                          file:FrameworkRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(VarType_ReaderDesc__storage_)
                                         flags:0];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - VarType_ChannelDesc

@implementation VarType_ChannelDesc

@dynamic hasDataType, dataType;
@dynamic hasCapacity, capacity;

typedef struct VarType_ChannelDesc__storage_ {
  uint32_t _has_storage_[1];
  VarType_Type dataType;
  int64_t capacity;
} VarType_ChannelDesc__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "dataType",
        .dataTypeSpecific.enumDescFunc = VarType_Type_EnumDescriptor,
        .number = VarType_ChannelDesc_FieldNumber_DataType,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(VarType_ChannelDesc__storage_, dataType),
        .flags = GPBFieldRequired | GPBFieldHasEnumDescriptor,
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "capacity",
        .dataTypeSpecific.className = NULL,
        .number = VarType_ChannelDesc_FieldNumber_Capacity,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(VarType_ChannelDesc__storage_, capacity),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[VarType_ChannelDesc class]
                                     rootClass:[FrameworkRoot class]
                                          file:FrameworkRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(VarType_ChannelDesc__storage_)
                                         flags:0];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - VarType_Tuple

@implementation VarType_Tuple

@dynamic elementTypeArray, elementTypeArray_Count;

typedef struct VarType_Tuple__storage_ {
  uint32_t _has_storage_[1];
  GPBEnumArray *elementTypeArray;
} VarType_Tuple__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "elementTypeArray",
        .dataTypeSpecific.enumDescFunc = VarType_Type_EnumDescriptor,
        .number = VarType_Tuple_FieldNumber_ElementTypeArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(VarType_Tuple__storage_, elementTypeArray),
        .flags = GPBFieldRepeated | GPBFieldHasEnumDescriptor,
        .dataType = GPBDataTypeEnum,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[VarType_Tuple class]
                                     rootClass:[FrameworkRoot class]
                                          file:FrameworkRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(VarType_Tuple__storage_)
                                         flags:0];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - VarDesc

@implementation VarDesc

@dynamic hasName, name;
@dynamic hasType, type;
@dynamic hasPersistable, persistable;

typedef struct VarDesc__storage_ {
  uint32_t _has_storage_[1];
  NSString *name;
  VarType *type;
} VarDesc__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "name",
        .dataTypeSpecific.className = NULL,
        .number = VarDesc_FieldNumber_Name,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(VarDesc__storage_, name),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "type",
        .dataTypeSpecific.className = GPBStringifySymbol(VarType),
        .number = VarDesc_FieldNumber_Type,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(VarDesc__storage_, type),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "persistable",
        .dataTypeSpecific.className = NULL,
        .number = VarDesc_FieldNumber_Persistable,
        .hasIndex = 2,
        .offset = 3,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional | GPBFieldHasDefaultValue,
        .dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[VarDesc class]
                                     rootClass:[FrameworkRoot class]
                                          file:FrameworkRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(VarDesc__storage_)
                                         flags:0];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - BlockDesc

@implementation BlockDesc

@dynamic hasIdx, idx;
@dynamic hasParentIdx, parentIdx;
@dynamic varsArray, varsArray_Count;
@dynamic opsArray, opsArray_Count;
@dynamic hasForwardBlockIdx, forwardBlockIdx;

typedef struct BlockDesc__storage_ {
  uint32_t _has_storage_[1];
  int32_t idx;
  int32_t parentIdx;
  int32_t forwardBlockIdx;
  NSMutableArray *varsArray;
  NSMutableArray *opsArray;
} BlockDesc__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescriptionWithDefault fields[] = {
      {
        .defaultValue.valueInt32 = 0,
        .core.name = "idx",
        .core.dataTypeSpecific.className = NULL,
        .core.number = BlockDesc_FieldNumber_Idx,
        .core.hasIndex = 0,
        .core.offset = (uint32_t)offsetof(BlockDesc__storage_, idx),
        .core.flags = GPBFieldRequired,
        .core.dataType = GPBDataTypeInt32,
      },
      {
        .defaultValue.valueInt32 = 0,
        .core.name = "parentIdx",
        .core.dataTypeSpecific.className = NULL,
        .core.number = BlockDesc_FieldNumber_ParentIdx,
        .core.hasIndex = 1,
        .core.offset = (uint32_t)offsetof(BlockDesc__storage_, parentIdx),
        .core.flags = GPBFieldRequired,
        .core.dataType = GPBDataTypeInt32,
      },
      {
        .defaultValue.valueMessage = nil,
        .core.name = "varsArray",
        .core.dataTypeSpecific.className = GPBStringifySymbol(VarDesc),
        .core.number = BlockDesc_FieldNumber_VarsArray,
        .core.hasIndex = GPBNoHasBit,
        .core.offset = (uint32_t)offsetof(BlockDesc__storage_, varsArray),
        .core.flags = GPBFieldRepeated,
        .core.dataType = GPBDataTypeMessage,
      },
      {
        .defaultValue.valueMessage = nil,
        .core.name = "opsArray",
        .core.dataTypeSpecific.className = GPBStringifySymbol(OpDesc),
        .core.number = BlockDesc_FieldNumber_OpsArray,
        .core.hasIndex = GPBNoHasBit,
        .core.offset = (uint32_t)offsetof(BlockDesc__storage_, opsArray),
        .core.flags = GPBFieldRepeated,
        .core.dataType = GPBDataTypeMessage,
      },
      {
        .defaultValue.valueInt32 = -1,
        .core.name = "forwardBlockIdx",
        .core.dataTypeSpecific.className = NULL,
        .core.number = BlockDesc_FieldNumber_ForwardBlockIdx,
        .core.hasIndex = 2,
        .core.offset = (uint32_t)offsetof(BlockDesc__storage_, forwardBlockIdx),
        .core.flags = GPBFieldOptional | GPBFieldHasDefaultValue,
        .core.dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[BlockDesc class]
                                     rootClass:[FrameworkRoot class]
                                          file:FrameworkRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescriptionWithDefault))
                                   storageSize:sizeof(BlockDesc__storage_)
                                         flags:GPBDescriptorInitializationFlag_FieldsWithDefault];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ProgramDesc

@implementation ProgramDesc

@dynamic blocksArray, blocksArray_Count;
@dynamic hasVersion, version;

typedef struct ProgramDesc__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *blocksArray;
  Version *version;
} ProgramDesc__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "blocksArray",
        .dataTypeSpecific.className = GPBStringifySymbol(BlockDesc),
        .number = ProgramDesc_FieldNumber_BlocksArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(ProgramDesc__storage_, blocksArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "version",
        .dataTypeSpecific.className = GPBStringifySymbol(Version),
        .number = ProgramDesc_FieldNumber_Version,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ProgramDesc__storage_, version),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ProgramDesc class]
                                     rootClass:[FrameworkRoot class]
                                          file:FrameworkRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ProgramDesc__storage_)
                                         flags:0];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end


#pragma clang diagnostic pop

// @@protoc_insertion_point(global_scope)
